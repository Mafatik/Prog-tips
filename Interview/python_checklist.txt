Типизация Python
	Динамическая -- типы переменных устанавливаются на этапе
	компиляции.
	Сильная (строгая) -- нельзя смешать в одном выражении
	разные типы данных. Например, нельзя сложить int и string
	Неявная -- тип переменной задается неявно

Типы данных
	int
	boolean
	float
	decimal
	complex
	string
	raw string r''
	list [] - изменяем.
	tuple () - неизменяем.
	set ([])
	dictionary {:}
	Преобразование типов происходит преимущественно через конструктор:
	Decimal(1.), list(tpl), set(lst)


Что такое итератор?
	Итератор -- это любой объект, реализующий метод __next__
	без аргументов, который должен вернуть следующий элемент
	или ошибку StopIteration. Также он реализует метод
	__iter__ и поэтому сам является итерируемым объектом.
	Осуществляет доступ к элементу класса без предоставления
	данных о его внутренней реализации, позволяет пробегать
	все элементы класса в некотором порядке.
	Заполнение массива итератором:
		lst = [x for x in range(5) if x%4 == 0]


Что такое генератор?
	Генератор -- то же, что и итератор, но позволяет отложенно
	создавать результат при итерации. Не выгружает в память все
	итерируемые объекты, а возвращает их на лету. Поэтому
	используется в работе с большим кол-вом объектов. Доступ к
	элементам объекта, заполненного генератором, нельзя получить
	более одного раза. Объект генератора имеет интерфейс итератора.
	Заполненние массива генератором:
		lst = (x for x in range(5) if x%4 == 0)


Для чего нужен yield?
	То же, что и return, но возвращает генератор. Функция, в
	которой есть yield называется генераторной функцией. При
	каждой итерации объекта, возвращаемого такой функцией
	выполняется код от того места, где закончилось исполнение
	кода в прошлый раз (или от начала функции) и до yield,
	возвращается значение. Как только код не может дойти до
	yield, функция прекращает работу.


Что такое декораторы?
	Декораторы -- «обёртки», которые дают нам возможность делать
	что-либо до и после того, что сделает декорируемая функция, не
	изменяя её.


Чем отличается _ и __?
	_ ОБОЗНАЧАЕТ, что член не желательно вызывать вне класса,
	однако, сделать это можно. __ дает большую защиту в том плане,
	что член по такому имени вызвать уже нельзя (можно, если 
	instance._ClassName__memberName).


Что такое лямбда-функции и где они используются?
	Лямбда-функции -- анонимные функции. Синтаксис объявления --
	lambda arguments: expression. Могут содержать только одно
	выражение, зато выполняются быстрее обычных методов.
	Вызов add_1 = lambda x: x + 1
	add(15) не обеспечивает как таковой анонимности, т.к.
	происходит присваивание пременной. Существует вызов 
	(lambda x, y: x * y)(3, 5) (возвратит 15). Функцию без
	параметров можно вызвать (lambda: "return")(). Можно задавать
	значения по умолчанию (могут заменяться на значения,
	возвращаемые в теле функции): (lambda x = 7, y: x + y)(15, 16).
	Могут использоваться, например, для задания компораторов для
	сортировок.

Что такое *args и **kwargs?
	Позволяют передавать в функцию переменное кол-во аргументов.
	*args для неименованных аргументов, **kwargs для именованных
	аргументов.	Параметры передаются как кортеж.

Что такое pip? Как с помощью него поставить пакет? Как просмотреть
все установленные пакеты? Что делать, если в нескольких разных
проектах используются разные версии одной библиотеки? 
	Менеджер пакетов.
	pip install LibName
	pip freeze
	использовать virtualenv

Как передаются аргументы в функцию: по значению или ссылке?
	Зависит от типа. Mutable передаются по объекту, immuytable --
	по ссылке.


is_none возвращает True если передать даже пустой массив, например.
В отличие от is None.

is сравнивает адреса == -- значения

Чем отличается =, copy.copy() и copy.deepcopy()?
	= копирует по ссылке
	deepcopy() может рекурсивно скопировать значения содержимого
	сложных структур (например, масиивов, вложенных массивов), в 
	то время как copy() скопирует только первый уровень вложенности.

Разница мкжду instancemethod @classmethod и @staticmethod
	instancemethod по умолчанию принимает self
	classmethod по умолчанию принимает cls. Может изменять состояние класса
	и всех инстансов
	staticmethod не принимает ни self, ни cls. Его можно применять, когда
	надо ввести метод, который никак не относится к классу. Например, метод
	в классе пицца, который считает площадь круга по пареметру-радиусу.

Подчеркивания в названиях полей/методов
	_var -- слабое "внутреннее" использование. Видно из наследников
	var_ -- избежать пересечения с ключевыми словами
	__var -- сильное "внутреннее" использование. Не видно из наследников
	__var__ -- магические методы (__init__(), тд). По факту то же, что и предыд


x = 10
def foo(x):
    x = 15
    return
foo(x)
x внутри функиции не меняется


Удаление повторящихся эл-тов в list
lst = [1, 2, 3, 1]
st = set(lst)
lst = list(st)


Написать генератор, который бесконечно перебирает элементы
переданного в него итерируемого объекта
	def gen(lst):
		while True:
			for x in lst:
				yield x


Написать декоратор, который будет удалять все 'o' к следующей
функции:
	def foo(a, b):
		return a + 'o' + и

	def decorator(foo):
    		def wrapped(a, b):
        	return foo(a, b).replace('o', '')
    	return wrapped

	@decorator
	def foo(a, b):
    		return a + 'o' + b
	

print [x for x in enumerate("abcd")]
__________________________________________________________________
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]


lst = (x for x in range(5))
print(lst)
for x in lst:
	print(x)
__________________________________________________________________
<generator object <genexpr> at 0x0000020A68620E58>
0
1
2
3
4


def gen_fun():
    print('block 1')
    yield 1
    print('block 2')
    yield 2
    print('end')

for i in gen_fun():
    print(i)
__________________________________________________________________
block 1
1
block 2
2
end


def cool_range(start, stop, inc):
    x = start
    while x < stop:
        yield x
        x += inc
for n in cool_range(1, 5, 0.5):
    print(n)


lst = [1, 2, 3, 4]
it = iter(lst)
it.__next__()
next(it)


def makebold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped
def makeitalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped
@makebold
@makeitalic
def hello():
    return "hello habr"
print hello()
__________________________________________________________________
<b><i>hello habr</i></b>


lst1 = [1, 2, 3, 4]
lst2 = lst1
lst2.append(5)
print(lst1, lst2)
__________________________________________________________________
[1, 2, 3, 4, 5] [1, 2, 3, 4, 5]
Переменная lst2 скопировалась по ссылке, поэтому изменилась и lst1.
Чтобы избежать такой дичи, юзать lst2 = lst1[:], lst2 = copy.copy(lst1) или 
lst2 = list(lst1). [:] означает выбор всех элементов


Свап
a = 5
b = 6
a, b = b, a


var = x if True else y


Разбиение строки по символу
lst = "text".split("d")


print(",".join(['1', '2', '3']))
__________________________________________________________________
1,2,3


imort datatime as dt
def foo(x = dt.datatime.now()):
	print (x)
foo()
foo()
foo()
Будет выводить все время одно и то же время, т.к. значение по
умолчанию определяется только один раза


def foo(x, a=[]):
	a.append(x)
	print(a)
foo(2)
foo(3, [1, 2])
foo(4)
__________________________________________________________________
[2]
[1, 2, 3]
[2, 4]
Т.к. в Python функция является объектом, она будет накапливать
значения по умолчанию, если в нее не передать какое-то другое
значение.


class Test():
    val = 'val'
    @classmethod
    def c_m(self):
        self.val = 'another val'
test = Test()
Test.c_m()
print(test.val)
test1 = Test()
print(test1.val)
__________________________________________________________________
another val
another val
